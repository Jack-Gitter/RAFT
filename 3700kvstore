#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random, math

BROADCAST = "FFFF"

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others
        self.leader_id = "FFFF"
        self.follower = True
        self.leader = False
        self.candidate = False
        self.election_timeout = random.uniform(.3, .6)
        self.term = 1
        self.log = {}
        self.votes = []

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def respond_to_client(self, msg):
        failmsg = {"src": str(self.id), "dst": msg['src'], "leader": msg['leader'], "type": "fail", "MID": msg['MID']}
        self.send(failmsg)

    def begin_election(self):
        self.candidate = True
        self.follower = False
        self.leader = False

    def send_request_vote_RPC(self):
        request_vote_rpc = {"src": str(self.id),
                "dst": BROADCAST,
                "leader": "FFFF",
                'type': 'request_vote_rpc',
                'MID': '1',
                "last_log_idx": str(len(self.log)-1),
                "term":self.term}
            

        print("sending vote request '%s'" % (request_vote_rpc,), flush=True)
        self.send(request_vote_rpc)
            
    def send_heartbeat(self):
        heartbeat = {"src": str(self.id), "dst": BROADCAST, "leader": str(self.id), "type": "heartbeat", "MID": '-1'}
        self.send(heartbeat)

    def analyze_votes(self):
        count = 0
        for vote in self.votes:
            if vote['vote_granted'] == True:
                count+=1
        if count >= math.ceil(len(self.others)/2):
            self.leader = True
            self.candidate = False
            self.follower = False
            self.send_heartbeat()
            print("I Am the leader!!!")
        else:
            self.leader = False
            self.candidate = False
            self.follower = True
            print("I am  a follower")


    def respond_to_vote_request(self, msg):
        response = {"src": str(self.id), "dst": msg['src'], "leader": "FFFF", "MID":"1", "type": "vote_response", "vote_granted": True}
        print("sending vote response '%s'" % (response,), flush=True)
        self.send(response)


    def run(self):
        # do an initial election here

        while True:
            socks = select.select([self.socket], [], [], self.election_timeout)[0] # add a timeout here so that this is the timeout to start a new election 
            for sock in socks:
                data, addr = sock.recvfrom(65535) # Receives maximum number of bytes from the socket that this replicate is listening on, blocking
                msg = data.decode('utf-8')
                msg = json.loads(msg)

                if self.leader:
                    self.send_heartbeat()
                print("Received message '%s'" % (msg,), flush=True)
                if msg['type'] == 'request_vote_rpc':
                    self.respond_to_vote_request(msg)
                elif msg['type'] == 'heartbeat':
                    self.votes = []
                    self.follower = True
                    self.leader = False
                    self.candidate = False
                elif msg['type'] == 'vote_response' and self.candidate:
                    self.votes.append(msg)
                    if len(self.votes) == len(self.others):
                        self.analyze_votes()
                        self.votes = []
                    # put self back into follower mode
                else:
                    print("Received message '%s'" % (msg,), flush=True)
                    #self.respond_to_client(msg)

            # If we have timed out
            if len(socks) == 0: 
                self.begin_election()
                self.send_request_vote_RPC()
                self.election_timeout = random.uniform(5, 10)
                # once any given thing becomes leader, send out a heartbeat and then that will put all the other things into follower mode!!!
                
                


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
